---
title: C语言实现线程池
date: 2023-07-07T17:08:13+08:00
tags: C
---
# 线程池的组成

1. 任务队列:

- 存储需要处理的任务,由工作线程来处理这些任务
- 通过线程池提供的API函数,将一个待处理的任务添加到任务队列中
- 已处理的任务会从任务队列中删除
- 线程池的使用者,也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程

2. 工作线程:

- 线程池中维护了一定数量的工作线程,他们的作用是不停的读任务队列,从里面取出任务并处理
- 工作的线程相当于是任务队列的消费者
- 如果任务队列为空,工作线程将被阻塞(条件变量/信号量阻塞)
- 如果阻塞之后有新的任务,由生产者解除阻塞,工作线程开始工作

3. 管理者线程:

- 管理者线程定期对任务队列及工作队列进行检测 
   - 当任务过多时,适当添加新的线程
   - 当任务过少时,适当销毁一些线程

# 线程池的设计

1. 管理者线程:

- 管理者线程只存在一个,使用一个ID保存起来

2. 工作线程:

- 工作线程存在N个,并且随时发生变化,可以通过动态数组保存起来

3. 任务队列:

- 任务队列中存在M个任务,这些任务是动态变化的,可以通过链表保存起来
- 每一个任务都有自己的处理方法和处理方法所需要的参数,所以使用一个结构体保存处理方法的函数指针和处理方法所需参数的泛型指针

# 函数设计

## 创建线程池并初始化

-  创建线程池就是为线程池结构体中的成员赋值,最终返回一个结构体 
-  线程池结构体只存在一个,所以函数返回创建线程池结构体的地址就行,之后的操作都是在操作这个线程池 

## 工作线程行为函数

- 先对线程池加锁,然后执行消费逻辑,若任务队列为空,使用条件变量wait等待唤醒
- 当对公共空间,如线程池或忙线程操作时,要提前加锁
- 取出任务后执行任务，并通过取余的方式将任务数减一，实现环形队列
- 任务执行完毕后，应将相关内存释放掉

### 虚假唤醒问题

``` c
pthread_mutex_lock(&pool->mutexPool);      
             //加锁
while (pool->queueSize == 0 && !pool->shutdown) {       //防止虚假唤醒

	//阻塞工作线程

	pthread_cond_wait(&pool->notEmpty, &pool->mutexPool);

}

pthread_mutex_unlock(&pool->mutexPool);                 //解锁

```

有多个线程被条件变量阻塞时,当生产者发送信号唤醒生产者时,至少唤醒一个,也就是说,会有多个消费者被唤醒,
第一个被唤醒的消费者先对线程池加锁,其他线程阻塞在锁上,当第一个消费者取得任务时,解锁,其他消费者解锁,
消费者解锁,会往下执行代码,可是这个时候任务队列可能就为空了,无法取到任务.

所以,在wait时,需要在外层设置while循环判断任务队列是否为空,而不是if判断

这样,在第一个消费者取出任务解锁时,第二个消费者加锁,出发while循环判断,判断任务队列为空,继续阻塞在条件变量wait上
## 管理者线程行为函数

- 管理者线程先对线程池加锁,取出所需参数:忙线程数、存活线程数和任务队列中的任务数
- 使用相应算法判断是否应对线程池进行扩充或缩窄操作
- 管理者线程函数中应添加睡眠操作，使管理者线程定期监控，减少对cpu的占用
## 为任务队列添加任务

- 任务队列是公共区域，对任务队列进行取出任务或添加任务操作时，应先加锁
- 使用与工作线程相同原理的whie循环为任务队列添加条件变量，防止虚假唤醒
- 为队列添加任务时，使用取余加一的方实现环形队列
## 线程池销毁

- 线程池销毁，是使用诱导工作线程自杀方式，通过改变标记变量shutdown，并发送虚假信号唤醒所有工作线程，使工作线程进入线程退出函数，实现工作线程的销毁
- 对于管理者线程，只需要让管理者线程正常退出循环即可